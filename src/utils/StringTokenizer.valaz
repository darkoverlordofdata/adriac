/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
namespace Utils 
{
    
	public errordomain Exception 
	{
		NullPointer,
		NoSuchElement,
		IllegalStateException,
		IllegalArgumentException,
		RuntimeException,
		NotReached
    }
    
    public class StringTokenizer : Object 
    {

        private int currentPosition;
        private int newPosition;
        private int maxPosition;
        private string str;
        private string delimiters;
        private bool retDelims;
        private bool delimsChanged;
        private int maxDelimCodePoint;
        private int[] delimiterCodePoints;

        public StringTokenizer(string str, string delim = " \t\n\r\f", bool returnDelims = false) 
        {
            currentPosition = 0;
            newPosition = -1;
            delimsChanged = false;
            this.str = str;
            maxPosition = str.length;
            delimiters = delim;
            retDelims = returnDelims;
            setMaxDelimCodePoint();
        }
            
        public void setMaxDelimCodePoint() 
        {
            if (delimiters == null) 
            {
                maxDelimCodePoint = 0;
                return;
            }

            var m = 0;
            var c = 0;
            var count = 0;
            for (var i=0 ; i<delimiters.length-1; i++) 
            {
                c = delimiters[i];
                if (m < c) m = c;
                count++;
            }
            maxDelimCodePoint = m;
        }

        public int skipDelimiters(int startPos) 
        {
            if (delimiters == null) 
            {
                throw new Exception.NullPointer("delimiters");
            }

            var position = startPos;
            while (!retDelims && position < maxPosition) 
            {
                var c = str[position];
                if ((c > maxDelimCodePoint) || !isDelimiter(c)) break;
                position += 1;
            }
            return position;
        }

        public int scanToken(int startPos) 
        {
            var position = startPos;
            while (position < maxPosition) 
            {
                var c = str[position];
                if ((c <= maxDelimCodePoint) && isDelimiter(c)) break;
                position += 1;
            }   
            if (retDelims && (startPos == position)) 
            {
                var c = str[position];
                if ((c <= maxDelimCodePoint) && isDelimiter(c)) position += 1;
            }
            return position;
        }


        public bool isDelimiter(char c) 
        {
            for (var i = 0; i<delimiters.length-1; i++)
                if (delimiters[i] == c) return true;
            return false;
        }

        public bool hasMoreTokens() 
        {
            newPosition = skipDelimiters(currentPosition);
            return newPosition < maxPosition;
        }

        public string nextToken(string delim = "") 
        {
            if (delim > "") 
            {
                delimiters = delim;
                delimsChanged = true;
            }
            currentPosition = newPosition >= 0 && !delimsChanged ? newPosition : skipDelimiters(currentPosition);

            delimsChanged = false;
            newPosition = -1;

            if (currentPosition >= maxPosition) throw new Exception.NoSuchElement("");
            var start = currentPosition;
            currentPosition = scanToken(currentPosition);
            return str.substring(start, currentPosition);
        }
        
        public int countTokens() 
        {
            var count = 0;
            var currpos = currentPosition;
            while (currpos < maxPosition) 
            {
                currpos = skipDelimiters(currpos);
                if (currpos >= maxPosition) break;
                currpos = scanToken(currpos);
                count++;
            }
            return count;
        }

        public string[] toArray(string skip = "") {
            string[] tokens = { };
            while (hasMoreTokens())
            {   
                var tok = nextToken();
                if (tok == null) {
                    print("NULL\n");
                }
                else
                {
                    print("|||%s|||\n", tok);
                }
                //  if (skip.index_of(tok)<0) {
                //      tokens += tok;
                //  }

            }
            return tokens;
        }
        //  tokens = []
        //  while @hasMoreTokens()
        //      tok = @nextToken()
        //      if skip.indexOf(tok) < 0
        //          tokens.push tok
        //  return tokens
        
    }
}

#!/usr/bin/env node
// Generated by CoffeeScript 2.0.0-alpha1

/*
## Copyright (c) 2017 Bruce Davidson &lt;darkoverlordofdata@gmail.com&gt;
## GPL3
##
##  Phase II - preprocess for emcc
##
## Inject missing forward references for boilerplate code
##      <class_name>_release
##      <class_name>_free
##      <class_name>_retain
##
## Problem:
##      CCode atrribute forward referenes are not propogated to other outputs
##      in the same compilation unit. This fixes the intermediate c files before
##      final compilation.
##
##  Assumptions: 
##      a folder corresponds to a namespace
##      files with PascalCase names contain reference counted classes
##      there is one such class per file
 */

(function() {
  var file, files, fixed, fs, i, inject, j, klass, lcfirst, len, len1, list, mangled, name, namespace, ns, options, path, ref, ref1, snakeCase;

  fs = require('fs');

  path = require('path');

  list = [];

  options = {};

  lcfirst = function(str) {
    return str.charAt(0).toLowerCase() + str.substr(1);
  };

  snakeCase = function(str) {
    return str.replace(/([A-Z])/g, function($0) {
      return "_" + $0.toLowerCase();
    });
  };

  inject = function(file, options) {
    var dst, flag, i, len, line, mangled, name, src;
    src = fs.readFileSync(file, 'utf8').split('\n');
    dst = [];
    for (i = 0, len = src.length; i < len; i++) {
      line = src[i];
      for (mangled in options) {
        name = options[mangled];
        if (line.indexOf(`#define _${mangled}_release0`) === 0) {
          flag = true;
          dst.push(`void ${mangled}_release (${name}* self);`);
          dst.push(`void ${mangled}_free (${name}* self);`);
          dst.push(`${name}* ${mangled}_retain (${name}* self);`);
        } else if (line.indexOf(`void ${mangled}_free (${name}* self);`) === 0) {
          flag = true;
          dst.push(`void ${mangled}_release (${name}* self);`);
          dst.push(`${name}* ${mangled}_retain (${name}* self);`);
        }
      }
      dst.push(line);
    }
    if (flag) {
      return fs.writeFileSync(file, dst.join('\n'));
    }
  };

  files = decodeURIComponent(process.argv[2]);

  if (files[0] === '"') {
    files = files.slice(1, -1);
  }

  ref = files.split(" ");
  for (i = 0, len = ref.length; i < len; i++) {
    file = ref[i];
    if (path.extname(file) === '.c') {
      klass = path.basename(file, '.c');
      if (klass[0] >= 'A' && klass[0] <= 'Z') {
        name = klass.toLowerCase();
        namespace = path.dirname(file).substring(10);
        fixed = snakeCase(lcfirst(klass));
        ns = namespace.replace(/\//g, "_");
        mangled = ns === "" ? fixed : `${ns}_${fixed}`;
        mangled = mangled.replace(/\//g, "_");
        options[mangled] = (ns + klass).replace(/\_/g, "");
      }
    }
  }

  ref1 = files.split(" ");
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    file = ref1[j];
    if (path.extname(file) === '.c') {
      inject(file, options);
    }
  }

}).call(this);

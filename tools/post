#!/usr/bin/env node
// Generated by CoffeeScript 2.0.0-alpha1

/*
## Copyright (c) 2017 Bruce Davidson &lt;darkoverlordofdata@gmail.com&gt;
## Apache 2.0 License
##
##  Phase II - preprocess for emcc
##
## Inject missing forward references for boilerplate code
##      <class_name>_release
##      <class_name>_free
##      <class_name>_retain
##
## Problem:
##      CCode atrribute forward referenes are not propogated to other outputs
##      in the same compilation unit. This fixes the intermediate c files before
##      final compilation.
##
##  Assumptions: 
##      a folder corresponds to a namespace
##      files with PascalCase names contain reference counted classes
##      there is one such class per file
 */

(function() {
  var buildDir, file, files, fixed, fs, i, inject, j, klass, lcfirst, len, len1, list, mangled, name, namespace, ns, options, path, ref, ref1, snakeCase, symtbl;

  fs = require('fs');

  path = require('path');

  list = [];

  options = {};

  lcfirst = function(str) {
    return str.charAt(0).toLowerCase() + str.substr(1);
  };

  snakeCase = function(str) {
    return str.replace(/([A-Z])/g, function($0) {
      return "_" + $0.toLowerCase();
    });
  };

  inject = function(file, options) {
    var dst, flag, i, len, line, ref, src;
    src = fs.readFileSync(file, 'utf8');
    dst = [];
    flag = false;
    ref = src.split('\n');
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      line.replace(/\#define\s+\_([_a-z0-9]+)_release0/, function($0, $1) {
        var type;
        type = symtbl[$1];
        if (type != null) {
          flag = true;
          dst.push(`void ${$1}_release (${type}* self);`);
          dst.push(`void ${$1}_free (${type}* self);`);
          return dst.push(`${type}* ${$1}_retain (${type}* self);`);
        }
      });
      line.replace(/\void\s+([_a-z0-9]+)_release\s+\((\w+)* self\)/, function($0, $1, $2) {
        var type;
        type = symtbl[$1];
        if (type != null) {
          flag = true;
          dst.push(`void ${$1}_release (${$2}* self);`);
          return dst.push(`${$2}* ${$1}_retain (${$2}* self);`);
        }
      });
      dst.push(line);
    }
    if (flag) {
      return fs.writeFileSync(file, dst.join('\n'));
    }
  };

  buildDir = process.argv[2];

  symtbl = JSON.parse(fs.readFileSync(`${buildDir}/symtbl.json`, 'utf8'));

  files = decodeURIComponent(process.argv[3]);

  if (files[0] === '"') {
    files = files.slice(1, -1);
  }

  ref = files.split(" ");
  for (i = 0, len = ref.length; i < len; i++) {
    file = ref[i];
    if (path.extname(file) === '.c') {
      klass = path.basename(file, '.c');
      if (klass[0] >= 'A' && klass[0] <= 'Z') {
        name = klass.toLowerCase();
        namespace = path.dirname(file).substring(10);
        fixed = snakeCase(lcfirst(klass));
        ns = namespace.replace(/\//g, "_");
        mangled = ns === "" ? fixed : `${ns}_${fixed}`;
        mangled = mangled.replace(/\//g, "_");
        options[mangled] = (ns + klass).replace(/\_/g, "");
      }
    }
  }

  ref1 = files.split(" ");
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    file = ref1[j];
    if (path.extname(file) === '.c') {
      inject(file, options);
    }
  }

}).call(this);

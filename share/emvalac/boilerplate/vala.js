// Generated by CoffeeScript 2.0.0-alpha1

/*
## Copyright (c) 2017 Bruce Davidson &lt;darkoverlordofdata@gmail.com&gt;
## GPL3
##
##  inject vala boilerplate
##
## Injects reference counting boilerplate into classes declared as:
##
##  <ClassName> : Object
##
 */

(function() {
  var fs, lcfirst, path, snakeCase;

  fs = require('fs');

  path = require('path');

  lcfirst = function(str) {
    return str.charAt(0).toLowerCase() + str.substr(1);
  };

  snakeCase = function(str) {
    return str.replace(/([A-Z])/g, function($0) {
      return "_" + $0.toLowerCase();
    });
  };

  module.exports = function(file, options) {
    var klass, name, namespace, src;
    klass = options["class"];
    name = options.name;
    namespace = options.namespace.replace(/\//g, "_");
    name = snakeCase(lcfirst(klass));
    src = fs.readFileSync(file, 'utf8');
    if (/^(\s*)public\s+class\s+\w*\s*\<\w,\s*\w\>\s*:\s*Object\s{*/mg.test(src)) {
      src = src.replace(/^(\s*)public\s+class\s+(\w*)\s*\<(\w,\s*\w)\>\s*:\s*(Object)\s*{/mg, function($0, $1, $2, $3, $4) {
        var n1, tab;
        tab = $1.replace(/\n/mg, "").replace("\t", "");
        n1 = namespace === "" ? "" : namespace + "_";
        return `${tab}[Compact, CCode ( /** reference counting */\n${tab}\tref_function = \"${n1}${name}_retain\", \n${tab}\tunref_function = \"${n1}${name}_release\"\n${tab})]\n${tab}public class ${$2}<${$3}> {\n${tab}\tpublic int _retainCount = 1;\n${tab}\tpublic unowned ${$2}<${$3}> retain() {\n${tab}\t\tGLib.AtomicInt.add (ref _retainCount, 1);\n${tab}\t\treturn this;\n${tab}\t}\n${tab}\tpublic void release() { \n${tab}\t\tif (GLib.AtomicInt.dec_and_test (ref _retainCount)) this.free ();\n${tab}\t}\n${tab}\tpublic extern void free();\n\t\t`;
      });
      return fs.writeFileSync(file, src);
    } else if (/^(\s*)public\s+class\s+\w*\s*\<\w\>\s*:\s*Object\s{*/mg.test(src)) {
      src = src.replace(/^(\s*)public\s+class\s+(\w*)\s*\<(\w)\>\s*:\s*(Object)\s*{/mg, function($0, $1, $2, $3, $4) {
        var n1, tab;
        tab = $1.replace(/\n/mg, "").replace("\t", "");
        n1 = namespace === "" ? "" : namespace + "_";
        return `${tab}[Compact, CCode ( /** reference counting */\n${tab}\tref_function = \"${n1}${name}_retain\", \n${tab}\tunref_function = \"${n1}${name}_release\"\n${tab})]\n${tab}public class ${$2}<${$3}> {\n${tab}\tpublic int _retainCount = 1;\n${tab}\tpublic unowned ${$2}<${$3}> retain() {\n${tab}\t\tGLib.AtomicInt.add (ref _retainCount, 1);\n${tab}\t\treturn this;\n${tab}\t}\n${tab}\tpublic void release() { \n${tab}\t\tif (GLib.AtomicInt.dec_and_test (ref _retainCount)) this.free ();\n${tab}\t}\n${tab}\tpublic extern void free();\n\t\t`;
      });
      return fs.writeFileSync(file, src);
    } else if (/^(\s*)public\s+class\s+\w*\s*:\s*Object\s{*/mg.test(src)) {
      src = src.replace(/^(\s*)public\s+class\s+(\w*)\s*:\s*(Object)\s*{/mg, function($0, $1, $2, $3) {
        var n1, tab;
        tab = $1.replace(/\n/mg, "").replace("\t", "");
        n1 = namespace === "" ? "" : namespace + "_";
        return `${tab}[Compact, CCode ( /** reference counting */\n${tab}\tref_function = \"${n1}${name}_retain\", \n${tab}\tunref_function = \"${n1}${name}_release\"\n${tab})]\n${tab}public class ${$2} {\n${tab}\tpublic int _retainCount = 1;\n${tab}\tpublic unowned ${$2} retain() {\n${tab}\t\tGLib.AtomicInt.add (ref _retainCount, 1);\n${tab}\t\treturn this;\n${tab}\t}\n${tab}\tpublic void release() { \n${tab}\t\tif (GLib.AtomicInt.dec_and_test (ref _retainCount)) this.free ();\n${tab}\t}\n${tab}\tpublic extern void free();\n\t\t`;
      });
      return fs.writeFileSync(file, src);
    } else if (/^(\s*)public\s+class\s+\w*\s*:\s*\w+\s*{/mg.test(src)) {
      src = src.replace(/^(\s*)public\s+class\s+(\w*)\s*:\s*(\w+)\s*{/mg, function($0, $1, $2, $3) {
        var tab;
        tab = $1.replace(/\n/mg, "").replace("\t", "");
        return `${tab}[Compact]\n${tab}public class ${$2} : ${$3} {\n${tab}\t`;
      });
      return fs.writeFileSync(file, src);
    }
  };

}).call(this);

// Generated by CoffeeScript 2.0.0-alpha1

/*
## Copyright (c) 2017 Bruce Davidson &lt;darkoverlordofdata@gmail.com&gt;
## Apache 2.0 License
##
##  inject genie boilerplate
##
## Injects reference counting boilerplate into classes declared as:
##
##  <ClassName> : Object
##
 */

(function() {
  var fs, lcfirst, path, snakeCase;

  fs = require('fs');

  path = require('path');

  lcfirst = function(str) {
    return str.charAt(0).toLowerCase() + str.substr(1);
  };

  snakeCase = function(str) {
    return str.replace(/([A-Z])/g, function($0) {
      return "_" + $0.toLowerCase();
    });
  };

  module.exports = function(file, options) {
    var klass, name, namespace, src;
    klass = options["class"];
    name = options.name;
    namespace = options.namespace.replace(/\//g, "_");
    name = snakeCase(lcfirst(klass));
    src = fs.readFileSync(file, 'utf8');
    if (/^	class\s+\w*\s*:\s*Object\s*/mg.test(src)) {
      src = src.replace(/^	class\s+(\w*)\s*:\s*(Object)\s*/mg, function($0, $1, $2) {
        return `\t[Compact, CCode ( /** reference counting */\n\t\tref_function = \"${namespace}_${name}_retain\", \n\t\tunref_function = \"${namespace}_${name}_release\"\n\t)]\n\tclass ${klass}\n\t\trefCount: int = 1\n\t\tdef retain() : unowned ${klass}\n\t\t\tGLib.AtomicInt.add (ref retainCount__, 1)\n\t\t\treturn this\n\t\tdef release() \n\t\t\tif GLib.AtomicInt.dec_and_test (ref retainCount__) do this.free ()\n\t\tdef extern free()\n\t\t`;
      });
      return fs.writeFileSync(file, src);
    } else if (/^class\s+\w*\s*:\s*Object\s*/mg.test(src)) {
      src = src.replace(/^class\s+(\w*)\s*:\s*(Object)\s*/mg, function($0, $1, $2) {
        return `[Compact, CCode ( /** reference counting */\n	ref_function = \"${name}_retain\", \n	unref_function = \"${name}_release\"\n)]\nclass ${klass}\n	retainCount__: int = 1\n	def retain() : unowned ${klass}\n		GLib.AtomicInt.add (ref retainCount__, 1)\n		return this\n	def release() \n		if GLib.AtomicInt.dec_and_test (ref retainCount__) do this.free ()\n	def extern free()\n\t`;
      });
      return fs.writeFileSync(file, src);
    } else if (/^	class\s+\w*\s*:\s*\w+\s*/mg.test(src)) {
      src = src.replace(/^	class\s+(\w*)\s*:\s*(\w+)\s*/mg, function($0, $1, $2) {
        return `\t[Compact]\n\tclass ${klass} : ${$2}\n\t\t`;
      });
      return fs.writeFileSync(file, src);
    } else if (/^class\s+\w*\s*:\s*\w+\s*/mg.test(src)) {
      src = src.replace(/^class\s+(\w*)\s*:\s*(\w+)\s*/mg, function($0, $1, $2) {
        return `[Compact]\nclass ${klass} : ${$2}\n\t`;
      });
      return fs.writeFileSync(file, src);
    }
  };

}).call(this);

#!/usr/bin/env node
// Generated by CoffeeScript 2.0.0-alpha1

/*
## Copyright (c) 2017 Bruce Davidson &lt;darkoverlordofdata@gmail.com&gt;
## GPL3
##
 */

(function() {
  var a, arg, args, buildDir, classes, classname, cmd, fs, i, inClass, j, klass, lcfirst, len, level, name, namespace, opts, outerKlass, path, pfx, snakeCase, src, sym, t, template, type;

  fs = require('fs');

  path = require('path');

  lcfirst = function(str) {
    return str.charAt(0).toLowerCase() + str.substr(1);
  };

  snakeCase = function(str) {
    return str.replace(/([A-Z])/g, function($0) {
      return "_" + $0.toLowerCase();
    });
  };

  template = function(file, name, options) {
    var klass, namespace, pfx, src;
    klass = options["class"];
    namespace = options.namespace;
    pfx = options.pfx;
    src = fs.readFileSync(file, 'utf8');
    if (/^(\s*)public\s+class\s+\w*\s*\<\w,\s*\w\>\s*:\s*Object\s{*/m.test(src)) {
      src = src.replace(/^(\s*)public\s+class\s+(\w*)\s*\<(\w,\s*\w)\>\s*:\s*(Object)\s*{/m, function($0, $1, $2, $3, $4) {
        var tab;
        tab = $1.replace(/\n/mg, "").replace("\t", "");
        return `${tab}[Compact, CCode ( /** reference counting */\n${tab}\tref_function = \"${pfx}_retain\", \n${tab}\tunref_function = \"${pfx}_release\"\n${tab})]\n${tab}public class ${$2}<${$3}> {\n${tab}\tpublic int _retainCount = 1;\n${tab}\tpublic unowned ${$2}<${$3}> retain() {\n${tab}\t\tGLib.AtomicInt.add (ref _retainCount, 1);\n${tab}\t\treturn this;\n${tab}\t}\n${tab}\tpublic void release() { \n${tab}\t\tif (GLib.AtomicInt.dec_and_test (ref _retainCount)) this.free ();\n${tab}\t}\n${tab}\tpublic extern void free();\n\t\t`;
      });
      fs.writeFileSync(file, src);
      return src;
    } else if (/^(\s*)public\s+class\s+\w*\s*\<\w\>\s*:\s*Object\s{*/m.test(src)) {
      src = src.replace(/^(\s*)public\s+class\s+(\w*)\s*\<(\w)\>\s*:\s*(Object)\s*{/m, function($0, $1, $2, $3, $4) {
        var tab;
        tab = $1.replace(/\n/mg, "").replace("\t", "");
        return `${tab}[Compact, CCode ( /** reference counting */\n${tab}\tref_function = \"${pfx}_retain\", \n${tab}\tunref_function = \"${pfx}_release\"\n${tab})]\n${tab}public class ${$2}<${$3}> {\n${tab}\tpublic int _retainCount = 1;\n${tab}\tpublic unowned ${$2}<${$3}> retain() {\n${tab}\t\tGLib.AtomicInt.add (ref _retainCount, 1);\n${tab}\t\treturn this;\n${tab}\t}\n${tab}\tpublic void release() { \n${tab}\t\tif (GLib.AtomicInt.dec_and_test (ref _retainCount)) this.free ();\n${tab}\t}\n${tab}\tpublic extern void free();\n\t\t`;
      });
      fs.writeFileSync(file, src);
      return src;
    } else if (/^(\s*)public\s+class\s+\w*\s*:\s*Object\s{*/m.test(src)) {
      src = src.replace(/^(\s*)public\s+class\s+(\w*)\s*:\s*(Object)\s*{/m, function($0, $1, $2, $3) {
        var tab;
        tab = $1.replace(/\n/mg, "").replace("\t", "");
        return `${tab}[Compact, CCode ( /** reference counting */\n${tab}\tref_function = \"${pfx}_retain\", \n${tab}\tunref_function = \"${pfx}_release\"\n${tab})]\n${tab}public class ${$2} {\n${tab}\tpublic int _retainCount = 1;\n${tab}\tpublic unowned ${$2} retain() {\n${tab}\t\tGLib.AtomicInt.add (ref _retainCount, 1);\n${tab}\t\treturn this;\n${tab}\t}\n${tab}\tpublic void release() { \n${tab}\t\tif (GLib.AtomicInt.dec_and_test (ref _retainCount)) this.free ();\n${tab}\t}\n${tab}\tpublic extern void free();\n\t\t`;
      });
      fs.writeFileSync(file, src);
      return src;
    } else if (/^(\s*)public\s+class\s+\w*\s*:\s*\w+\s*{/m.test(src)) {
      src = src.replace(/^(\s*)public\s+class\s+(\w*)\s*:\s*(\w+)\s*{/m, function($0, $1, $2, $3) {
        var tab;
        tab = $1.replace(/\n/mg, "").replace("\t", "");
        return `${tab}[Compact]\n${tab}public class ${$2} : ${$3} {\n${tab}\t`;
      });
      fs.writeFileSync(file, src);
      return src;
    }
  };

  buildDir = process.argv[2];

  cmd = decodeURIComponent(process.argv[3]);

  if (cmd[0] === '"') {
    cmd = cmd.slice(1, -1);
  }

  args = cmd.split(" ");

  sym = {};

  for (j = 0, len = args.length; j < len; j++) {
    arg = args[j];
    namespace = '';
    pfx = [];
    classes = {};
    klass = '';
    outerKlass = '';
    inClass = false;
    if (arg === "") {
      continue;
    }
    src = fs.readFileSync(arg, 'utf8');
    a = src.split(/\s+/);
    i = 0;
    level = 0;
    while (i < a.length) {
      switch (a[i]) {
        case '{':
          level++;
          break;
        case '}':
          level--;
          break;
        case 'namespace':
          i++;
          namespace = a[i];
          break;
        case 'class':
          i++;
          klass = a[i];
          if (klass.indexOf('<') > 0) {
            klass = klass.slice(0, +(klass.indexOf('<') - 1) + 1 || 9e9);
          }
          if (namespace === '' && level > 0) {
            classname = outerKlass + '.' + klass;
            pfx = snakeCase(lcfirst(klass));
            type = lcfirst(outerKlass) + klass;
            classes[classname] = {
              namespace: namespace,
              outer: outerKlass,
              "class": klass,
              type: type,
              pfx: pfx
            };
          } else if (namespace !== '' && level > 1) {
            classname = namespace + '.' + outerKlass + '.' + klass;
            pfx = namespace.toLowerCase().replace(/\./g, '_') + '_' + snakeCase(lcfirst(outerKlass)) + '_' + klass.toLowerCase();
            type = namespace.replace(/\./g, '') + outerKlass + klass;
            classes[classname] = {
              namespace: namespace,
              outer: outerKlass,
              "class": klass,
              type: type,
              pfx: pfx
            };
          } else {
            outerKlass = klass;
            if (namespace === '') {
              classname = klass;
              pfx = snakeCase(lcfirst(klass));
              type = klass;
              classes[classname] = {
                namespace: namespace,
                outer: '',
                "class": klass,
                type: type,
                pfx: pfx
              };
            } else {
              classname = namespace + '.' + klass;
              pfx = namespace.toLowerCase().replace(/\./g, '_') + '_' + snakeCase(lcfirst(klass));
              type = namespace.replace(/\./g, '') + klass;
              classes[classname] = {
                namespace: namespace,
                outer: '',
                "class": klass,
                type: type,
                pfx: pfx
              };
            }
          }
      }
      i++;
    }
    for (name in classes) {
      opts = classes[name];
      t = path.extname(arg);
      if (t === '.vala') {
        sym[opts.pfx] = opts.type;
        template(arg, name, opts);
      }
    }
  }

  fs.writeFileSync(`${buildDir}/symtbl.json`, JSON.stringify(sym, null, 2));

}).call(this);
